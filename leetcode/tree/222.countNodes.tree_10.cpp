#include<iostream>
#include<queue>
using namespace std;

// 递归
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    return countNodes(root -> left) + countNodes(root -> right) + 1;
}

// 迭代
int countNodes(TreeNode* root) {
    int ans = 0;
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    while (!que.empty()) {
        int size = que.size();
        ans += size;
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            if (node -> left) que.push(node -> left);
            if (node -> right) que.push(node -> right);
        }
    }
    return ans;
}

// 二分查找



// review
int countNodes(TreeNode* root) {
    if (!root) return 0;

    return countNodes(root -> left) + countNodes(root -> right) + 1;
}

// 利用层数
int countNodes(TreeNode* root) {
    if (!root) return 0;
    int left = countLevel(root -> left);
    int right = countLevel(root -> right);
    if (left == right) {
        return countNodes(root -> right) + (1 << left);
    } else {
        return countNodes(root -> left) + (1 << right);
    }
}

int countLevel(TreeNode* root) {
    int level = 0;
    while (root) {
        level++;
        root = root -> left;
    }
    return level;
}

// 二分法
// 求二叉树的深度
int countLevel(TreeNode* root) {
    int level = 0;
    while (root) {
        level++;
        root = root -> left;
    }
    return level;
}

bool is_exist(TreeNode* root, int index, int depth) {
    TreeNode* node = root;
    while (depth) {
        // 最后一层分界线
        int mid = ((1 << depth) >> 1);
        if (index > mid) {
            index -= mid;
            node = node -> right;
        } else {
            node = node -> left;
        }
        depth -= 1;
    }
    return node != nullptr;
}

int countNodes(TreeNode* root) {
    if (!root) return 0;

    // 二叉树深度
    int depth = countLevel(root);
    int depth_prev = depth - 1;

    int start = 1, end = (1 << depth_prev), mid = 0;
    while (start <= end) {
        mid = start + ((end - start) >> 1);
        if (is_exist(root, mid, depth_prev)) start = mid + 1;
        else end = mid - 1;
    }

    int ret = (1 << depth_prev) - 1 + start - 1;
    return ret;
}

// copy other
int countLevels(TreeNode* root) {
    int levels = 0;
    while (root) {
        root = root->left; levels += 1;
    }
    return levels;
}

/*
* 功能： 判断最后一层第index个索引是否存在
* root： 二叉树根节点
* index：判断最后一层索引为index的节点是否存在, 索引范围是[1, 2^depth]
* depth：倒数第二层的深度, 这是因为满二叉树最后一层的节点数等于 2^depth
*/
bool is_exist(TreeNode* root, int index, int depth) {
    TreeNode* node = root;
    while (depth) {
        // 最后一层分界线
        int mid = ((1 << depth) >> 1);
        if (index > mid) {
            // 如果在右子树，需要更新索引值
            index -= mid;
            node = node->right;
        }
        else {
            node = node->left;
        }
        depth -= 1;
    }
    return node != nullptr;
}

int countNodes(TreeNode* root) {
    // 3. 二分查找
    if (root == nullptr) return 0;
    // 二叉树深度
    int depth = countLevels(root);
    // 倒数第二层深度
    int depth_prev = depth - 1;

    int start = 1, end = (1 << depth_prev), mid = 0;
    while (start <= end) {
        mid = start + ((end - start) >> 1);
        if (is_exist(root, mid, depth_prev)) start = mid + 1;
        else end = mid - 1;
    }
    // start - 1为最后一层节点数
    int ret = (1 << depth_prev) - 1 + start - 1;
    return ret;
}
