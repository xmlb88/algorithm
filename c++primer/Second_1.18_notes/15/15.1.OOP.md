### 15.1 OOP:概述 ###

- 面向对象程序设计
- object-oriented programming
- 数据抽象、继承和动态绑定 将类的接口与实现分离
- 继承：定义相似的类型并对其相似关系建模
- 动态绑定：可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

- 继承 inheritance
- 基类 base class
- 派生类 derived class

- 例子：
- Quote类作为基类，派生出另一个名为Bulk_quote的类
- > 包含下面的2个成员函数：
- > isbn()：返回书籍的ISBN编号，该操作不涉及派生类的特殊性，只定义在Quote类中
- > net_price(size_t)，返回书籍的世纪销售价格，前提是用户购买该书的数量达到一定的标准，这个操作是类型相关的，Quote和Bulk_quote类都应该包含该函数

- 对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function) Quote类：

```c++
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```

- 派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个（哪些）基类继承而来的：

```c++
class Bulk_quote : public Quote {   // Bulk_quote继承了Quote
public:
    double net_price(std::size_t) const override;
};
```

- 因为Bulk_quote在它的派生列表中使用了public关键字，因此我们完全可以把Bulk_quote的对象当成Quote的对象来使用
- 派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做
- c++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数。+override关键字


- 动态绑定 dynamic binding
- example

```c++
// 计算并打印销售给定数量的某种书籍所得的费用
double print_total(ostream &os, const Quote &item, size_t n) {
    // 根据传入item形参的对象类型调用Quote::net_price
    // 或者Bulk_quote::net_price
    double ret = item.net_price(n);
    os << "ISBN: " << item.isbn() 
       << " # sold: " << n << " total due: " << ret << endl;
    return ret;
}


// basic的类型是Quote; bulk的类型是Bulk_quote
print_total(cout, basic, 20);   // 调用Quote的net_price
print_total(cout, bulk, 20);    // 调用Bulk_quote的net_price
```

- 动态绑定又被称为运行时绑定 run-time binding
- 当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定

### 15.2 定义基类和派生类 ###

```c++
// Quote类的定义：
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price) :
        bookNo(book), price(sales_price) {}
    std::string isbn() const { return bookNo; }
    // 返回给定数量的书籍的销售总额
    // 派生类负责改写并使用不同的折扣计算算法
    virtual double net_price(std::size_t n) const
        { return n * price; }
    virtual ~Quote() = default; // 对析构函数进行动态绑定
private:
    std::string bookNo;
protected:
    double price = 0.0; // 普通状态下不打折的价格
};
```

- 记住：作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

- 成员函数与继承
- 覆盖 override
- 2种成员函数：
- 一种是基类希望其派生类进行覆盖的函数
- 另一种是基类希望派生类直接继承而不要改变的函数
- 对于前者，基类通常将其定义为虚函数 virtual，任何构造函数之外的非静态函数都可以是虚函数，关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义，如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数
- 如果没被声明为虚函数，则其解析过程发生在编译时而非运行时

- 访问控制与继承
- 和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问
- 受保护的 protected

#### 15.2.2 定义派生类 ####

- 通过使用类派生列表 class derivation list

```c++
class Bulk_quote::public Quote {    // Bulk_quote继承自Quote
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);
    // 覆盖基类的函数版本以实现基于大量购买的折扣政策
    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0;    // 使用折扣政策的最低购买量
    double discount = 0.0;  // 以小数表示的折扣额
};
```

- 派生类中的虚函数
- 经常(但不总是)覆盖它继承的函数
- 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本

page:530
