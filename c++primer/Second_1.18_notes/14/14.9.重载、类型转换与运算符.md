```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
```

### 14.9.1 类型转换运算符 ###

- 定义含有类型转换运算符的类
- operator *type*() const;
- example

```c++
class SmallInt {
public:
    SmallInt(int i = 0) : val(i) {
        if (i < 0 || i > 255)
            throw std::out_of_range("Bad SmallInt value");
    }
    operator int() const { return val; }
private:
    std::size_t val;
};

SmallInt si;
si = 4; // 首先将4隐式地转换成SmallInt, 然后调用SmallInt::operator=
si + 3; // 首先将si隐式地转换成int, 然后执行整数的加法

```

```c++
// 内置类型转换将double实参转换成int
SmallInt si = 3.14;  //  调用SmallInt(int)构造函数
// SmallInt的类型转换运算符将si转换成int
si + 3.14;  // 内置类型转换将所得的int继续转换成double
```

> 类型转换运算符是隐式执行的，无法给这些函数传递实参，不能在类型转换运算符的定义中
> 使用任何形参；同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数
> 都会返回一个对应类型的值

```c++
class SmallInt;
operator int(SmallInt&);    // 错误：不是成员函数
class SmallInt {
public:
    int operator int() const;   // 错误：指定了返回类型
    operator int(int = 0) const;    // 错误：实参列表不为空
    operator int*() const { return 42; } // 错误：42不是一个指针
    operator int() const { return val; }
};
```
